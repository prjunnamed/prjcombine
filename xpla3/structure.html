<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Device structure - Project Combine</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Project Combine</h1>

                    <div class="right-buttons">

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="device-structure"><a class="header" href="#device-structure">Device structure</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>An XPLA3 device is made of:</p>
<ul>
<li>the ZIA (Zero-power Interconnect Array), which routes various signals to FB inputs; the routable signals include:
<ul>
<li>MC outputs</li>
<li>IOB outputs (ie. input buffers from general purpose I/O)</li>
<li>GCLK input buffers</li>
<li>a special POR (power-on reset) signal that is pulsed at device startup</li>
</ul>
</li>
<li>2-32 FBs (function blocks), each of which has:
<ul>
<li>two <code>FCLK[i]</code> fast clock networks, routable from <code>GCLK</code> pads</li>
<li>40 routable inputs from ZIA</li>
<li>48 PTs (product terms) shared between all MCs, each of them having one special function that can be used
instead of (or in addition to) being included in MC sum terms:
<ul>
<li>PT0-7: directly (with programmable inversion) drive LCTs (local control terms), which can be routed to control
inputs of all MCs within this FB; the possible uses of each LCT include:
<ul>
<li>LCT0-2: RST/SET, OE</li>
<li>LCT3: RST/SET</li>
<li>LCT4: CLK, RST/SET, CE</li>
<li>LCT5: CLK, RST/SET</li>
<li>LCT6: CLK, OE, UCTs (on XCR3032XL only)</li>
<li>LCT7: CLK, UCTs</li>
</ul>
</li>
<li>PT8-38 (even): fast data input to MC0-15, respectively</li>
<li>PT9-39 (off): dedicated CLK or CE input to MC0-15, respectively</li>
<li>PT40-47: foldback NANDs, the PT outputs are inverted and fed back as possible inputs to all PTs in this FB</li>
</ul>
</li>
<li>16 MCs (macrocells), each of which has:
<ul>
<li>a sum term, including an arbitrary subset of this FB's PTs</li>
<li>a LUT2 implementing an arbitrary function of the sum term and the fast data input PT</li>
<li>a register, with:
<ul>
<li>D input tied to either the LUT2 output, or this MC's input buffer (sidestepping the ZIA)</li>
<li>configurable mode, one of: DFF, TFF, D latch, DFF with clock enable</li>
<li>clock (or latch gate), freely invertible and routable from LCT4-7, FCLK0-1, dedicated per-MC PT, or UCT0</li>
<li>async set and reset, both routable from LCT0-5, UCT2 (set), UCT3 (reset), or const 0</li>
<li>clock enable, routable from LCT4 or dedicated per-MC PT</li>
<li>always 0 initial value</li>
</ul>
</li>
<li>output to ZIA, routed either from the LUT2 (combinatorial) or the register's Q output (registered)</li>
<li>IOB (input/output buffer) (on larger devices, not all MCs have an IOB), with:
<ul>
<li>input buffer (routed to ZIA and this MC's register D input)</li>
<li>output to ZIA, routed either from the input buffer or from the MC's register Q output</li>
<li>either combinatorial (from LUT2) or registered (from register's Q) output to the output buffer, selectable
independently from ZIA output</li>
<li>output enable, routable from LCT0-2, LCT6, UCT1, const 0, const 1</li>
<li>optional pull-up (can only be used when OE is tied to 0)</li>
<li>configurable slew rate (fast or slow)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>global signals
<ul>
<li>the 4 GCLK dedicated inputs, routable to ZIA and per-FB <code>FCLK</code> networks</li>
<li>the 4 UCTs (Universal Control Terms), routable from LCT7 of all FBs (and, on XCR3032XL, also LCT6 of all FBs);
UCTs can be used to drive control signals throughout the whole device:
<ul>
<li>UCT0: CLK</li>
<li>UCT1: OE</li>
<li>UCT2: RST</li>
<li>UCT3: SET</li>
</ul>
</li>
</ul>
</li>
<li>special global configuration bits
<ul>
<li>JTAG pins disable bit (if not programmed, the IOBs corresponding to JTAG pins are connected to the TAP instead of their MCs)</li>
<li>user electronic signature bits (free-form field, size varies with device)</li>
<li>read protection enable</li>
</ul>
</li>
</ul>
<h2 id="fb-columns-and-rows"><a class="header" href="#fb-columns-and-rows">FB columns and rows</a></h2>
<p>The FBs in the device are organized in a 2D structure of columns and rows.</p>
<p>Each FB column has its own branch of the ZIA, and actually contains two FBs per row:
one on each side of the ZIA.  The FBs are nubered as follows:</p>
<ul>
<li>Even-numbered FBs are on one side of the ZIA branch of their column, and odd-numbered are on
the other</li>
<li>When increasing FB number from odd to even, move to the next FB row</li>
<li>If already at the last FB row, move to the next FB column and first FB row</li>
</ul>
<p>For example, the xcr3384xl device is organized as follows:</p>
<pre><code>+-----+-----------+-----------+-----------+
| Row | Column 0  | Column 1  | Column 2  |
+=====+=====+=====+=====+=====+=====+=====+
|  0  |  0  |  1  |  8  |  9  |  16 |  17 |
+-----+-----+-----+-----+-----+-----+-----+
|  1  |  2  |  3  |  10 |  11 |  18 |  19 |
+-----+-----+-----+-----+-----+-----+-----+
|  2  |  4  |  5  |  12 |  13 |  20 |  21 |
+-----+-----+-----+-----+-----+-----+-----+
|  3  |  6  |  7  |  14 |  15 |  22 |  23 |
+-----+-----+-----+-----+-----+-----+-----+
</code></pre>
<h2 id="zia-and-fb-inputs"><a class="header" href="#zia-and-fb-inputs">ZIA and FB inputs</a></h2>
<p>The core interconnect structure in XPLA3 devices is called ZIA, the Zero-power Interconnect Array.
It is a classic CPLD design.</p>
<p>Each FB has 40 inputs from ZIA, which we call <code>FB[i].IM[j]</code>.  Each FB input is controlled
by a set of fuses:</p>
<ul>
<li>
<p>mux fuses (<code>FB[i].IM[j].MUX</code>) select what is routed to the input.  The combinations include:</p>
<ul>
<li><code>VCC</code>: the input is const 1 (for unused inputs)</li>
<li><code>GND</code>: the input is const 0 (not very useful)</li>
<li><code>MC_{k}_{l}</code>: the input is routed from the macrocell output <code>FB[k].MC[l].MC_ZIA_OUT</code></li>
<li><code>IOB_{k}_{l}</code>: the input is routed from the macrocell output <code>FB[k].MC[l].IOB_ZIA_OUT</code></li>
<li><code>GCLK{i}</code>: the input is routed from the input buffer of dedicated <code>GCLK{i}</code> pin;
for this choice to work, the relevant <code>FB_COL[*].ZIA_GCLK{i}_ENABLE</code> fuse has to be enabled</li>
<li><code>STARTUP</code>: the input is routed to the special <code>STARTUP</code> network</li>
</ul>
<p>The allowable combinations differ between inputs within a single FB, but don't differ across
FBs within a single device.  In other words, the set of allowed values for these fuses
depends only on the <code>j</code> coordinate, but not on <code>i</code>.</p>
</li>
</ul>
<p>The ZIA lines corresponding to <code>GCLK*</code> inputs are gated, for the purpose for power saving.
The gating is per-FB column, and is controlled by the following fuses:</p>
<ul>
<li><code>FB_COL[i].ZIA_GCLK{j}_ENABLE</code>: if programmed, <code>GCLK{i}</code> can be routed through ZIA to FBs
within this column.  Otherwise, the <code>GCLK{i}</code> option above is non-functional and will result
in XXX.  Routing <code>GCLK*</code> to <code>FCLK*</code> is always possible, regardless of this fuse.</li>
</ul>
<p>TODO: while ISE sets the fuse as if the above is true, disabling the fuse doesn't actually seem to make ZIA GCLK routing not work. what's going on?</p>
<p>The <code>STARTUP</code> net is a special device-wide net that is pulsed to <code>1</code> for a short time at device
initialization, then remains at <code>0</code> afterwards.  It can be connected as the <code>SET</code> input
to a register to effectively obtain a <code>1</code>-initialized register.</p>
<h2 id="fclk-networks"><a class="header" href="#fclk-networks">FCLK networks</a></h2>
<p>Every FB has two fast clock nets, <code>FCLK[0-1]</code>.  They can be routed to the clock input
of every MC within the FB.  They can be routed from <code>GCLK*</code> input pads in many combinations.</p>
<p>The <code>FCLK*</code> routing is selected by a single fuse set per FB that selects both inputs
at once:</p>
<ul>
<li>
<p><code>FB[i].FCLK_MUX</code>: selects <code>FCLK*</code> routing for this FB.  The values are:</p>
<ul>
<li><code>GCLK{j}_GCLK{k}</code>: routes <code>FCLK0</code> to <code>GCLK{j}</code> and <code>FCLK1</code> to <code>GCLK{k}</code></li>
<li><code>GCLK{j}_NONE</code>: routes <code>FCLK0</code> to <code>GCLK{j}</code> and <code>FCLK1</code> to const 0</li>
<li><code>NONE_GCLK{j}</code>: routes <code>FCLK0</code> to const 0 and <code>FCLK1</code> to <code>GCLK{j}</code></li>
<li><code>NONE</code>: routes <code>FCLK[0-1]</code> to const 0</li>
</ul>
<p>See the database for the exact set of allowed values.</p>
</li>
</ul>
<h2 id="product-terms"><a class="header" href="#product-terms">Product terms</a></h2>
<p>As the name suggests, XPLA3 has a PLA-like structure.  Each FB has 48 product terms, all of
which are routable to sum terms of all MCs within that FB.  We call them <code>FB[i].PT[j]</code>. In addition, each product term
also has a single dedicated function it can be used for:</p>
<ul>
<li>PTs 0-7 are used to derive Local Control Terms (LCTs), which can be routed to special inputs
of all MCs within the FB</li>
<li>PTs 8-38 (even) can be used as fast data input (D1) of MCs 0-15, respectively.  This data input
can be combined with the slower sum term input via a programmable LUT2.</li>
<li>PTs 9-39 (odd) can be used as dedicated clock or CE input to registers of MCs 0-15, respectively.</li>
<li>PTs 40-47 can be used for foldback NAND: the output of these product term is inverted and can
be further used as input to other product terms within the same FB.</li>
</ul>
<p>The inputs to all product terms within the FB are the same and include:</p>
<ul>
<li>the 40 <code>FB[i].IM[*]</code> signals, both true and negated</li>
<li>the 8 foldback NAND signals from the same FB, <code>FB[i].PT[40-47]</code>, negated only</li>
</ul>
<p>The fuses controlling a product term are:</p>
<ul>
<li><code>FB[i].PT[j].IM[k].P</code>: if programmed (set to 0), <code>FB[i].IM[k]</code> is included in the product term (true polarity)</li>
<li><code>FB[i].PT[j].IM[k].N</code>: if programmed (set to 0), <code>~FB[i].IM[k]</code> is included in the product term (inverted polarity)</li>
<li><code>FB[i].PT[j].FBN[k]</code>: if programmed (set to 0), <code>~FB[i].PT[40+k]</code> is included in the product term (foldback NAND, inverted polarity)</li>
</ul>
<h3 id="local-control-terms"><a class="header" href="#local-control-terms">Local control terms</a></h3>
<p>Every FB has 8 LCTs (local control terms), which are derived from PT 0-7 respectively, via an optional inversion::</p>
<p>FB[i].LCT{j} = FB[i].PT[j] ^ FB[i].LCT{j}_INV</p>
<p>The fuses controlling LCTs are:</p>
<ul>
<li><code>FB[i].LCT{j}_INV</code>: if programmed, LCT j is inverse of PT j; otherwise LCT j is equal to PT jed_to_jtag</li>
</ul>
<p>The LCTs can be used for the following purposes:</p>
<div class="table-wrapper"><table><thead><tr><th>LCT</th><th>CLK</th><th>RST</th><th>SET</th><th>CE</th><th>OE</th><th>UCT</th></tr></thead><tbody>
<tr><td>0</td><td>❌</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr>
<tr><td>1</td><td>❌</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr>
<tr><td>2</td><td>❌</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr>
<tr><td>3</td><td>❌</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>4</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr>
<tr><td>5</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>6</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>*</td></tr>
<tr><td>7</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td></tr>
</tbody></table>
</div>
<p>*: on XCR3032XL only</p>
<h3 id="universal-control-terms"><a class="header" href="#universal-control-terms">Universal control terms</a></h3>
<p>The device has 4 UCTs (universal control terms).  On the XCR3032XL, all UCTs are routable
from LCT6 and LCT7 of all FBs.  On other devices, all the UCTs are routaeble from only LCT7 off
all FBs.</p>
<p>The UCTs can be routed to special inputs of all macrocells on the device.  They have fixed functions:</p>
<ul>
<li>UCT 0: can be routed to OE of all MCs</li>
<li>UCT 1: can be routed to RST of all MCs</li>
<li>UCT 2: can be routed to SET of all MCs</li>
<li>UCT 3: can be routed to CLK of all MCs</li>
</ul>
<p>The "universal" name is a slight misnomer.  On all devices other than XCR3512XL, the UCTs are truly
universal and cover the entire device.  However, on XCR3512XL, the FBs of the device are
divided into two FB groups, and each group has their own UCT muxes.  The vendor toolchain doesn'T
make use of this functionality and always mirrors UCT mux setting between the two groups.</p>
<p>The relevant fuse sets are:</p>
<ul>
<li>
<p><code>FB_GROUP[i].UCT{j}</code>: selects the signal routed to <code>UCT{j}</code> of FB group <code>i</code> (all devices other than XCR3512XL have only FB group 0)</p>
<ul>
<li><code>FB{k}_LCT{l}</code>: the UCT is driven by the given LCT of the given FB</li>
<li><code>NONE</code>: the UCT is unused and will be const-0</li>
</ul>
</li>
</ul>
<p>TODO: exact FB assignment to groups on XCR3512XL</p>
<h2 id="sum-term-lut2"><a class="header" href="#sum-term-lut2">Sum term, LUT2</a></h2>
<p>Every MC in the device has a sum term, <code>FB[i].MC[j].SUM</code>, which can be constructed from all
product terms within the same FB.  Is is controlled by the following fuses:</p>
<ul>
<li><code>FB[i].MC[j].SUM.PT[k]</code>: if programmed (set to 0), <code>FB[i].PT[k]</code> is included in the sum term for <code>FB[i].MC[j]</code></li>
</ul>
<p>The sum term, together with the fast input product term, are fed into a programmable LUT2 which
determines the given macrocell's combinatorial output and can also be routed to the register's
data input.  The LUT2 can be used for many purposes:</p>
<ul>
<li>select between the sum term and the fast product term</li>
<li>serve as a XOR or AND gate between the sum term and fast product term</li>
<li>perform inversion</li>
</ul>
<p>The LUT2 is controlled by a fuse set:</p>
<ul>
<li><code>FB[i].MC[j].LUT</code>: a 4-bit fuse set configuring the LUT2</li>
</ul>
<p>The LUT2 works as follows:</p>
<pre><code>select = FB[i].MC[j].SUM | FB[i].PT[8 + j * 2] &lt;&lt; 1
FB[i].MC[j].LUT_OUT = FB[i].MC[j].LUT[select]
</code></pre>
<h2 id="register"><a class="header" href="#register">Register</a></h2>
<p>Each macrocell has a register.  It has:</p>
<ul>
<li>four modes of operation:
<ul>
<li>DFF</li>
<li>TFF</li>
<li>D latch</li>
<li>DFF with clock enable</li>
</ul>
</li>
<li>D or T input routable from one of:
<ul>
<li>LUT output</li>
<li>pad input buffer (so-called fast input register)</li>
<li>the Q output of the previous register in the FB (wrapping from 0 to 15) (so-called fast shift register)</li>
<li>the Q output of the next register in the FB (wrapping from 15 to 0) (so-called fast shift register)</li>
</ul>
</li>
<li>clock or gate input routable from one of:
<ul>
<li><code>FCLK*</code></li>
<li><code>LCT[4-7]</code></li>
<li><code>UCT3</code></li>
<li>dedicated per-MC product term</li>
</ul>
</li>
<li>configurable inversion on the clock or gate input</li>
<li>(in DFF with clock enable mode only) clock enable input routable to one of:
<ul>
<li>dedicated per-MC product term</li>
<li><code>LCT4</code></li>
</ul>
</li>
<li>asynchronous reset, routable from:
<ul>
<li><code>LCT[0-5]</code></li>
<li><code>UCT1</code></li>
<li>const-0</li>
</ul>
</li>
<li>asynchronous set, routable from:
<ul>
<li><code>LCT[0-5]</code></li>
<li><code>UCT2</code></li>
<li>const-0</li>
</ul>
</li>
<li>initial state of 0</li>
</ul>
<p>The fuses involved are:</p>
<ul>
<li>
<p><code>FB[i].MC[j].CLK_MUX</code>: selects CLK input</p>
<ul>
<li><code>PT</code>: dedicated product term <code>9 + j * 2</code></li>
<li><code>FCLK[0-1]</code>: per-FB <code>FCLK[0-1]</code> network</li>
<li><code>LCTx</code>: per-FB local control term</li>
<li><code>UCT3</code>: universal control term</li>
</ul>
</li>
<li>
<p><code>FB[i].MC[j].CLK_INV</code>: if programmed, the CLK input is inverted (ie. clock is negedge)</p>
</li>
<li>
<p><code>FB[i].MC[j].RST_MUX</code>: selects RST input</p>
<ul>
<li><code>LCTx</code>: per-FB local control term</li>
<li><code>UCT1</code>: universal control term</li>
<li><code>GND</code>: const 0</li>
</ul>
</li>
<li>
<p><code>FB[i].MC[j].SET_MUX</code>: selects SET input</p>
<ul>
<li><code>LCTx</code>: per-FB local control term</li>
<li><code>UCT1</code>: universal control term</li>
<li><code>GND</code>: const 0</li>
</ul>
</li>
<li>
<p><code>FB[i].MC[j].CE_MUX</code>: selects CE input (only relevant in <code>DFFCE</code> mode)</p>
<ul>
<li><code>PT</code>: dedicated product term <code>9 + j * 2</code></li>
<li><code>LCTx</code>: per-FB local control term</li>
</ul>
</li>
<li>
<p><code>FB[i].MC[j].REG_MODE</code>: selects FF mode</p>
<ul>
<li><code>DFF</code></li>
<li><code>TFF</code></li>
<li><code>LATCH</code></li>
<li><code>DFFCE</code></li>
</ul>
</li>
<li>
<p><code>FB[i].MC[j].REG_D_IREG</code>: if programmed, and the <code>REG_D_SHIFT</code> fuse is not programmed, the register D input is connected to <code>FB[i].MC[j].IOB.I</code>; if neither is programmed, the register D input is connected to <code>FB[i].MC[j].LUT_OUT</code></p>
</li>
<li>
<p><code>FB[i].MC[j].REG_D_SHIFT</code>: if programmed, the register D input is connected to the previous or next MC's register Q output; otherwise, the connection is determined by <code>REG_D_IREG</code> fuse</p>
</li>
<li>
<p><code>FB[i].MC[j].REG_D_SHIFT_DIR</code>: when the previous fuse is programmed, determines which MC's register Q output is connected to this register's D input</p>
<ul>
<li><code>UP</code>: D input connected to <code>FB[i].MC[(j - 1) % 16].REG</code></li>
<li><code>DOWN</code>: D input connected to <code>FB[i].MC[(j + 1) % 16].REG</code></li>
</ul>
</li>
</ul>
<p>The register works as follows:</p>
<pre><code>case(FB[i].MC[j].CLK_MUX)
    PT: FB[i].MC[j].CLK = FB[i].PT[9 + j * 2]. ^ FB[i].MC[j].CLK_INV;
    LCTx: FB[i].MC[j].CLK = FB[i].LCTx ^ FB[i].MC[j].CLK_INV;
    UCT3: FB[i].MC[j].CLK = FB_GROUP[block_to_block_group(i)].UCT3 ^ FB[i].MC[j].CLK_INV;
    FCLKx: FB[i].MC[j].CLK = FB[i].FCLKx ^ FB[i].MC[j].CLK_INV;
endcase

case(FB[i].MC[j].RST_MUX)
    LCTx: FB[i].MC[j].RST = FB[i].LCTx;
    UCT1: FB[i].MC[j].RST = FB_GROUP[block_to_block_group(i)].UCT1;
    GND: FB[i].MC[j].RST = 0;
endcase

case(FB[i].MC[j].SET_MUX)
    LCTx: FB[i].MC[j].SET = FB[i].LCTx;
    UCT2: FB[i].MC[j].SET = FB_GROUP[block_to_block_group(i)].UCT2;
    GND: FB[i].MC[j].SET = 0;
endcase

case(FB[i].MC[j].CE_MUX)
    PT: FB[i].MC[j].CE = FB[i].PT[9 + j * 2];
    LCT4: FB[i].MC[j].CE = FB[i].LCT4;
endcase

if (FB[i].MC[j].REG_D_SHIFT)
    case(FB[i].MC[j].REG_D_SHIFT_DIR)
    UP: FB[i].MC[j].REG_D = FB[i].MC[(j - 1) % 16].REG;
    DOWN: FB[i].MC[j].REG_D = FB[i].MC[(j + 1) % 16].REG;
    endcase
else if (FB[i].MC[j].REG_D_IREG)
    FB[i].MC[j].REG_D = FB[i].MC[j].IOB.I;
else
    FB[i].MC[j].REG_D = FB[i].MC[j].LUT_OUT;

initial FB[i].MC[j].REG = 0;

case(FB[i].MC[j].REG_MODE)
    // Pretend the usual synth/sim mismatch doesn't happen.
    DFF:
        always @(posedge FB[i].MC[j].CLK, posedge FB[i].MC[j].RST, posedge FB[i].MC[j].SET)
            if (FB[i].MC[j].RST)
                FB[i].MC[j].REG = 0;
            else if (FB[i].MC[j].SET)
                FB[i].MC[j].REG = 1;
            else
                FB[i].MC[j].REG = FB[i].MC[j].REG_D;
    TFF:
        always @(posedge FB[i].MC[j].CLK, posedge FB[i].MC[j].RST, posedge FB[i].MC[j].SET)
            if (FB[i].MC[j].RST)
                FB[i].MC[j].REG = 0;
            else if (FB[i].MC[j].SET)
                FB[i].MC[j].REG = 1;
            else
                FB[i].MC[j].REG ^= FB[i].MC[j].REG_D;
    LATCH:
        always @*
            if (FB[i].MC[j].RST)
                FB[i].MC[j].REG = 0;
            else if (FB[i].MC[j].SET)
                FB[i].MC[j].REG = 1;
            else if (FB[i].MC[j].CLK)
                FB[i].MC[j].REG = FB[i].MC[j].REG_D;
    DFFCE:
        always @(posedge FB[i].MC[j].CLK, posedge FB[i].MC[j].RST, posedge FB[i].MC[j].SET)
            if (FB[i].MC[j].RST)
                FB[i].MC[j].REG = 0;
            else if (FB[i].MC[j].SET)
                FB[i].MC[j].REG = 1;
            else if (FB[i].MC[j].CE)
                FB[i].MC[j].REG = FB[i].MC[j].REG_D;
endcase
</code></pre>
<h2 id="macrocell-and-iob-outputs"><a class="header" href="#macrocell-and-iob-outputs">Macrocell and IOB outputs</a></h2>
<p>Macrocells come in two variants: ones with IOBs and buried macrocells (without IOBs).</p>
<p>A macrocell with IOB has two outputs to ZIA:</p>
<ul>
<li><code>FB[i].MC[j].MC_ZIA_OUT</code>: routable from the LUT2 or register output</li>
<li><code>FB[i].MC[j].IOB_ZIA_OUT</code>: routable from the IOB's input buffer or register output</li>
</ul>
<p>A macrocell with IOB also has an output to the IOB:</p>
<ul>
<li><code>FB[i].MC[j].MC_IOB_OUT</code>: routable from the LUT2 or register output</li>
</ul>
<p>The muxes for all three of the above signals are independent, allowing any two of
IBUF, LUT2, and register output to be routed to the ZIA, and also independently connect
either LUT2 or register output to the output buffer.</p>
<p>A buried macrocell has only one output to ZIA, <code>FB[i].MC[j].MC_ZIA_OUT</code>.  It is thus
not possible to use both its combinatorial and registered output at the same time.</p>
<p>The fuses involved are:</p>
<ul>
<li>
<p><code>FB[i].MC[j].MC_ZIA_MUX</code>: controls routing to <code>FB[i].MC[j].MC_ZIA_OUT</code></p>
<ul>
<li><code>REG</code>: routes from <code>FB[i].MC[j].REG</code></li>
<li><code>LUT</code>: routes from <code>FB[i].MC[j].LUT_OUT</code></li>
</ul>
</li>
<li>
<p><code>FB[i].MC[j].MC_IOB_MUX</code>: controls routing to <code>FB[i].MC[j].MC_IOB_OUT</code></p>
<ul>
<li><code>REG</code>: routes from <code>FB[i].MC[j].REG</code></li>
<li><code>LUT</code>: routes from <code>FB[i].MC[j].LUT_OUT</code></li>
</ul>
</li>
<li>
<p><code>FB[i].MC[j].IOB_ZIA_MUX</code>: controls routing to <code>FB[i].MC[j].IOB_ZIA_OUT</code></p>
<ul>
<li><code>REG</code>: routes from <code>FB[i].MC[j].REG</code></li>
<li><code>IBUF</code>: routes from <code>FB[i].MC[j].IOB.I</code></li>
</ul>
</li>
</ul>
<h2 id="inputoutput-buffer"><a class="header" href="#inputoutput-buffer">Input/output buffer</a></h2>
<p>All I/O buffers (except <code>GCLK*</code> pins which are input-only) are associated with a macrocell.
Not all MCs have associated IOBs.</p>
<p>The output buffer is controlled by the <code>FB[i].MC[j].MC_IOB_OUT</code> and <code>FB[i].MC[j].OE</code> signals of the macrocell.</p>
<p>The OE signal is routable from:</p>
<ul>
<li><code>GND</code>: const-0 (input-only pin)</li>
<li><code>VCC</code>: const-1 (output-only pin)</li>
<li><code>LCT[0126]</code>: local control terms</li>
<li><code>UCT0</code>: universal control term</li>
<li><code>PULLUP</code>: special option; like <code>GND</code>, but also enables a weak pull-up on the pin</li>
</ul>
<p>The output slew rate is programmable between two settings, "fast" and "slow".</p>
<p>Each I/O buffer has the following fuses:</p>
<ul>
<li>
<p><code>FB[i].MC[j].OE_MUX</code>: selects output enable source</p>
<ul>
<li><code>GND</code>: const-0</li>
<li><code>VCC</code>: const-1</li>
<li><code>LCTx</code>: per-FB local control term</li>
<li><code>UCT1</code>: universal control term</li>
<li><code>PULLUP</code>: const-0 and enable weak pull-up resistor</li>
</ul>
</li>
<li>
<p><code>FB[i].MC[j].IOB_SLEW</code>: selects slew rate, one of:</p>
<ul>
<li><code>SLOW</code></li>
<li><code>FAST</code></li>
</ul>
</li>
</ul>
<h2 id="misc-configuration"><a class="header" href="#misc-configuration">Misc configuration</a></h2>
<p>The XPLA3 devices also have some global configuration fuses that affect the whole device:</p>
<ul>
<li><code>READ_PROT</code>: if programmed, the device is read-protected, and the bitstream cannot be read back (except for UES area)</li>
<li><code>ISP_DISABLE</code>: if programmed, and not overriden by <code>PORT_EN</code>, the special function of the JTAG pins is disabled, and the pins are controlled by the macrocells as normal I/O; if not programmed, the JTAG pins retain their special functions and the relevant IOBs are disconnected from macrocell control</li>
<li><code>UES</code> (user electronic signature): this scratchpad multi-bit field can be used for any user-defined purpose; it is exempt from read protection; the exact size of this field varies with device</li>
</ul>
<p>When used by ISE, the UES field stores 8-bit ASCII data, with MSB-first bit numbering (ie. bit 0 of <code>UES</code> is the MSB of first character).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../xpla3/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../xpla3/bitstream.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../xpla3/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../xpla3/bitstream.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
